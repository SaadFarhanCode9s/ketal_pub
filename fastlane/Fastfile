require 'yaml'

skip_docs

enterprise = '../Enterprise/Pipeline/Scripts/iOS/Fastfile'
if File.exist?(enterprise)
  import enterprise
end

simulator_version = "26.1"

before_all do
  xcversion(version: "~> 26.1.0")

  ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "180"
  ENV["FASTLANE_XCODE_LIST_TIMEOUT"] = "180"
  ENV["SENTRY_LOG_LEVEL"] = "DEBUG"
end

lane :unit_tests do |options|
  reset_simulator = ENV.key?('CI')
  
  run_tests(
    scheme: "UnitTests",
    device: "iPhone 17 (#{simulator_version})",
    ensure_devices_found: true,
    result_bundle: true,
    number_of_retries: 3,
    reset_simulator: reset_simulator,
    xcodebuild_formatter: "xcbeautify --quiet --is-ci --renderer github-actions"
  )
  
  if !options[:skip_previews]
    create_simulator_if_necessary(
      name: "iPhone SE (3rd generation)",
      type: "com.apple.CoreSimulator.SimDeviceType.iPhone-SE-3rd-generation"
    )

    run_tests(
      scheme: "PreviewTests",
      device: "iPhone SE (3rd generation) (#{simulator_version})",
      ensure_devices_found: true,
      result_bundle: true,
      number_of_retries: 3,
      reset_simulator: reset_simulator,
      xcodebuild_formatter: "xcbeautify --quiet --is-ci --renderer github-actions"
    )
  end
  
  # We use xcresultparser in the workflow to collect coverage from both result bundles.
end

lane :ui_tests do |options|
  # We used to run these simultaneously on iPhone and iPad but it is *really* slow on GitHub runners.
  # Presumably because launching 2 simulators uses more memory than the runner has available.
  
  if options[:device] == "iPhone"
    device = "iPhone-#{simulator_version}"
    
    create_simulator_if_necessary(
      name: "iPhone-#{simulator_version}",
      type: "com.apple.CoreSimulator.SimDeviceType.iPhone-17"
    )
  elsif options[:device] == "iPad"
    device = "iPad-#{simulator_version}"
    
    create_simulator_if_necessary(
      name: "iPad-#{simulator_version}",
      type: "com.apple.CoreSimulator.SimDeviceType.iPad-A16"
    )
  else
    UI.user_error!("Please supply a device argument as device:iPhone or device:iPad")
  end

  if options[:test_name]
    test_to_run = ["UITests/#{options[:test_name]}"]
  else
    test_to_run = nil
  end

  reset_simulator = ENV.key?('CI')
  
  run_tests(
    scheme: "UITests",
    device: "#{device} (#{simulator_version})",
    ensure_devices_found: true,
    prelaunch_simulator: false,
    result_bundle: true,
    only_testing: test_to_run,
    number_of_retries: 3,
    reset_simulator: reset_simulator,
    xcodebuild_formatter: "xcbeautify --quiet --is-ci --renderer github-actions"
  )
end

lane :accessibility_tests do |options|
  reset_simulator = ENV.key?('CI')
  
  run_tests(
    scheme: "AccessibilityTests",
    device: "iPhone 16 (18.5)", # The tests are randomly crashing on iOS 26
    ensure_devices_found: true,
    prelaunch_simulator: false,
    result_bundle: true,
    number_of_retries: 0,
    reset_simulator: reset_simulator,
    xcodebuild_formatter: "xcbeautify --quiet --is-ci --renderer github-actions"
  )
end


lane :integration_tests do
  clear_derived_data()

  reset_simulator = ENV.key?('CI')

  run_tests(
    scheme: "IntegrationTests",
    device: "iPhone 17 (#{simulator_version})",
    ensure_devices_found: true,
    result_bundle: true,
    reset_simulator: reset_simulator,
    xcodebuild_formatter: "xcbeautify --quiet --is-ci --renderer github-actions"
  )
end

lane :config_production do
  update_foss_secrets()
  xcodegen(spec: "project.yml")
end

lane :config_nightly do |options|
  build_number = options[:build_number]
  UI.user_error!("Invalid build number.") unless !build_number.to_s.empty?

  target_file_path = "../project.yml"
  data = YAML.load_file target_file_path
  
  # Check if the "path" already exists in the "include" array
  if !data["include"].any? { |item| item["path"] == "Variants/Nightly/nightly.yml" }
    data["include"].append({ "path" => "Variants/Nightly/nightly.yml" })
  end

  update_foss_secrets()
  
  File.open(target_file_path, 'w') { |f| YAML.dump(data, f) }

  xcodegen(spec: "project.yml")

  # Automatically done by Xcode Cloud. Cannot override
  # https://developer.apple.com/documentation/xcode/setting-the-next-build-number-for-xcode-cloud-builds
  # bump_build_number()

  release_version = get_version_number(target: "ketal")

  Dir.chdir ".." do
    sh("swift run tools app-icon-banner Variants/Nightly/Resources/NightlyAppIcon.icon/Assets/Version.png --banner-text '#{release_version} (#{build_number})'")
  end
end

$sentry_retry=0
lane :upload_dsyms_to_sentry do |options|
  auth_token = ENV["SENTRY_AUTH_TOKEN"]
  UI.user_error!("Invalid Sentry Auth token.") unless !auth_token.to_s.empty?

  dsym_path = options[:dsym_path]
  UI.user_error!("Invalid DSYM path.") unless !dsym_path.to_s.empty?

  begin
    sentry_upload_dif(
      auth_token: auth_token,
      org_slug: 'element',
      project_slug: 'element-x-ios',
      url: 'https://sentry.tools.element.io/',
      path: dsym_path,
    )
  rescue => exception
    $sentry_retry += 1

    if $sentry_retry <= 5
      UI.message "Sentry failed, retrying."
      upload_dsyms_to_sentry options
    else
      raise exception
    end
  end
end

lane :release_to_github do
  api_token = ENV["GITHUB_TOKEN"]
  UI.user_error!("Invalid GitHub API token.") unless !api_token.to_s.empty?

  release_version = get_version_number(target: "ketal")

  github_release = set_github_release(
    repository_name: "element-hq/element-x-ios",
    api_token: api_token,
    name: release_version,
    tag_name: "release/#{release_version}",
    is_generate_release_notes: true,
  )
  
  release_date = Date.today.strftime("%Y-%m-%d")
  generated_notes = github_release["body"].gsub(/<!-- .*? -->/, '').gsub("### ", "\n").gsub("## ", "### ")
  UI.user_error!("The generated release notes are missing!") unless !generated_notes.to_s.empty?
  
  # Prepend the new release notes to the CHANGES.md file
  changes_file = "../CHANGES.md"
  File.open(changes_file, "r+") do |file|
    content = file.read
    file.rewind
    file.write("## Changes in #{release_version} (#{release_date})#{generated_notes}\n\n#{content}")
  end
  
  # The changelog will be committed when prepare_next_release is called.
  sh("git add #{changes_file}")
end

lane :prepare_next_release do
  target_file_path = "../project.yml"
  xcode_project_file_path = "../ketal.xcodeproj"

  data = YAML.load_file target_file_path
  current_version = data["settings"]["MARKETING_VERSION"]
  
  matches = current_version.match(/^(\d{2})\.(\d{2})\.(\d+)$/)
  unless matches
    UI.user_error!("Invalid version format: #{current_version}")
  end

  year, month, build = matches.captures
  new_build = build.to_i + 1
  new_version = "#{year}.#{month}.#{new_build}"

  # Bump the patch version. The empty string after -i is so that sed doesn't
  # create a backup file on macOS
  sh("sed -i '' 's/MARKETING_VERSION: #{current_version}/MARKETING_VERSION: #{new_version}/g' #{target_file_path}")
  UI.message("Version updated from #{current_version} to #{new_version}")

  xcodegen(spec: "project.yml")

  setup_git()

  sh("git add #{target_file_path} #{xcode_project_file_path}")

  sh("git commit -m 'Prepare next release'")

  git_push()

  rebase_main_onto_current_branch()
end

def rebase_main_onto_current_branch
  # Capture the current branch name
  current_branch = sh("git rev-parse --abbrev-ref HEAD").strip

  UI.message("Current branch: #{current_branch}")

  # Switch to main and update it
  sh("git reset --hard")
  sh("git checkout main")
  sh("git pull origin main")
  sh("git rebase #{current_branch}")

  git_push()

  UI.success("Successfully rebased main onto #{current_branch}")
end

lane :tag_nightly do |options|
  build_number = options[:build_number]
  UI.user_error!("Invalid build number.") unless !build_number.to_s.empty?

  xcodegen_project_file_path = "../project.yml"
  data = YAML.load_file xcodegen_project_file_path
  current_version = data["settings"]["MARKETING_VERSION"]

  setup_git()

  tag_name = "nightly/#{current_version}.#{build_number}"
  sh("git tag #{tag_name}")

  git_push(tag_name: tag_name)
end

private_lane :setup_git do
  sh("git config --global user.name 'Element CI'")
  sh("git config --global user.email 'ci@element.io'")
end

private_lane :git_push do |options|
  # Use the Github API token for repo write access
  api_token = ENV["GITHUB_TOKEN"]
  UI.user_error!("Invalid GitHub API token.") unless !api_token.to_s.empty?

  # Get repo url path, without `http`, `https` or `git@` prefixes or `.git` suffix
  repo_url = sh("git ls-remote --get-url origin | sed 's#http://##g' | sed 's#https:\/\/##g' | sed 's#git@##g' | sed 's#.git##g'")

  # This sometimes has a trailing newline
  repo_url = repo_url.strip

  # Push the tag separately if available
  if options[:tag_name]
    sh("git push https://#{api_token}@#{repo_url} #{options[:tag_name]}")
  end
    
  sh("git push https://#{api_token}@#{repo_url}")
end

private_lane :bump_build_number do
  # Increment build number to current date
  build_number = Time.now.strftime("%Y%m%d%H%M")
  increment_build_number(build_number: build_number)
end

private_lane :create_simulator_if_necessary do |options|
  simulator_name = options[:name]
  UI.user_error!("Invalid simulator name") unless !simulator_name.to_s.empty?

  simulator_type = options[:type]
  UI.user_error!("Invalid simulator type") unless !simulator_type.to_s.empty?

  simulator_runtime = "com.apple.CoreSimulator.SimRuntime.iOS-#{simulator_version.gsub('.', '-')}"

  simulators = sh("xcrun simctl list devices \"iOS #{simulator_version}\" available")
  # Use a `(` here to avoid matching `iPhone 14 Pro` on `iPhone 14 Pro Max` for example
  existing_simulator = simulators.lines.find { |line| line.include?("#{simulator_name} (") }
  
  if existing_simulator
    UI.message("Found simulator: #{existing_simulator.inspect}")
    device_id = existing_simulator.match(/\(([A-F0-9-]+)\)/)[1] # Extract the device ID for the existing simulator
  else
    UI.message "Simulator #{simulator_name} not found. Creating new simulatorâ€¦"
    create_command = "xcrun simctl create '#{simulator_name}\' #{simulator_type} #{simulator_runtime}"
    device_id = sh(create_command).strip # Create a new simulator and get its device ID.
    
    UI.message "Created new simulator: #{simulator_name} (#{device_id})"
  end
  
  # device_id is unused right now but is useful to check e.g. the boot status of a simulator.
end

lane :deploy_testflight do
  # 1. Setup API Key
  api_key = app_store_connect_api_key(
    key_id: ENV["ASC_KEY_ID"],
    issuer_id: ENV["ASC_ISSUER_ID"],
    key_content: ENV["ASC_KEY_CONTENT"],
    duration: 1200,
    in_house: false
  )

  # 2. Import Certificates and Provisioning Profiles
  import_code_signing_assets()

  # 3. Build App
  build_app(
    project: "ketal.xcodeproj",
    scheme: "ketal",
    clean: true,
    export_method: "app-store",
    export_options: {
      provisioningProfiles: {
        "io.ketal.app" => "Ketal App Store Profile",
        "io.ketal.app.nse" => "Ketal NSE App Store Profile"
      }
    }
  )

  # 4. Upload to TestFlight
  upload_to_testflight(
    api_key: api_key,
    skip_waiting_for_build_processing: true
  )
  
  # 5. Cleanup
  cleanup_keychain()
end

# Private lane to import certificates and provisioning profiles from environment variables
private_lane :import_code_signing_assets do
  # Validate required environment variables
  certificate_base64 = ENV["CERTIFICATE_P12_BASE64"]
  p12_password = ENV["P12_PASSWORD"]
  main_profile_base64 = ENV["PROVISIONING_PROFILE_BASE64"]
  nse_profile_base64 = ENV["NSE_PROVISIONING_PROFILE_BASE64"]
  
  UI.user_error!("CERTIFICATE_P12_BASE64 is missing") if certificate_base64.to_s.empty?
  UI.user_error!("P12_PASSWORD is missing") if p12_password.to_s.empty?
  UI.user_error!("PROVISIONING_PROFILE_BASE64 is missing") if main_profile_base64.to_s.empty?
  UI.user_error!("NSE_PROVISIONING_PROFILE_BASE64 is missing") if nse_profile_base64.to_s.empty?

  # Create temporary directory for certificates
  cert_dir = File.expand_path("~/fastlane_tmp")
  FileUtils.mkdir_p(cert_dir)
  
  # Decode and save certificate
  cert_path = "#{cert_dir}/certificate.p12"
  File.write(cert_path, Base64.decode64(certificate_base64))
  
  # Decode and save provisioning profiles
  main_profile_path = "#{cert_dir}/main.mobileprovision"
  nse_profile_path = "#{cert_dir}/nse.mobileprovision"
  File.write(main_profile_path, Base64.decode64(main_profile_base64))
  File.write(nse_profile_path, Base64.decode64(nse_profile_base64))
  
  # Create temporary keychain
  keychain_name = "fastlane_keychain"
  keychain_password = SecureRandom.hex(16)
  
  ENV["FASTLANE_KEYCHAIN_NAME"] = keychain_name
  ENV["FASTLANE_KEYCHAIN_PASSWORD"] = keychain_password
  
  create_keychain(
    name: keychain_name,
    password: keychain_password,
    default_keychain: false,
    unlock: true,
    timeout: 3600,
    lock_when_sleeps: false
  )
  
  # Import certificate into keychain
  import_certificate(
    certificate_path: cert_path,
    certificate_password: p12_password,
    keychain_name: keychain_name,
    keychain_password: keychain_password,
    log_output: true
  )
  
  # Install provisioning profiles
  install_provisioning_profile(path: main_profile_path)
  install_provisioning_profile(path: nse_profile_path)
  
  UI.success("Successfully imported certificates and provisioning profiles")
end

private_lane :cleanup_keychain do
  keychain_name = ENV["FASTLANE_KEYCHAIN_NAME"]
  
  if keychain_name && !keychain_name.empty?
    delete_keychain(name: keychain_name)
    UI.success("Cleaned up keychain: #{keychain_name}")
  end
  
  # Clean up temporary directory
  cert_dir = File.expand_path("~/fastlane_tmp")
  FileUtils.rm_rf(cert_dir) if File.exist?(cert_dir)
end